# -*- coding: utf-8 -*-
###############################################################################
# Copyright (c), The AiiDA-CP2K authors.                                      #
# SPDX-License-Identifier: MIT                                                #
# AiiDA-CP2K is hosted on GitHub at https://github.com/cp2k/aiida-cp2k        #
# For further information on the license, see the LICENSE.txt file.           #
###############################################################################


from itertools import chain
from aiida.common.exceptions import InputValidationError


class Cp2kInput(object):
    DISCLAIMER = "!!! Generated by AiiDA !!!"

    def __init__(self, params=None):
        self._params = params if params else {}

    def add_keyword(self, kwpath, value):
        _add_keyword(kwpath.split("/"), value, self._params)

    def to_file(self, fhandle):
        fhandle.write(f"{self.DISCLAIMER}\n")
        for line in _render_cp2k_section(self._params):
            fhandle.write(f"{line}\n")

    def to_string(self):
        return "\n".join(chain([self.DISCLAIMER], _render_cp2k_section(self._params)))


def _add_keyword(kwpath, value, params):
    if len(kwpath) == 1:  # simple key/value for the current params
        params[kwpath[0]] = value

    else:  # the keyword is not for the current level
        if kwpath[0] not in params.keys():  # make sure that the section exists
            params[kwpath[0]] = {}

        _add_keyword(kwpath[1:], value, params[kwpath[0]])


def _render_cp2k_section(params, indent=0, indent_width=3):
    """
    It takes a nested dictionary/list structure and yields line for a CP2K input file.

    For key-value pair it checks whether the value is a dictionary
    and prepends the key with & (CP2K section).
    It passes the value to the same function, increasing the indentation
    If the value is a list, I assume that this is something the user
    wants to store repetitively
    eg:
        dict['KEY'] = ['val1', 'val2']
        ===>
        KEY val1
        KEY val2

        or

        dict['KIND'] = [{'_': 'Ba', 'ELEMENT':'Ba'},
                        {'_': 'Ti', 'ELEMENT':'Ti'},
                        {'_': 'O', 'ELEMENT':'O'}]
        ====>
              &KIND Ba
                 ELEMENT  Ba
              &END KIND
              &KIND Ti
                 ELEMENT  Ti
              &END KIND
              &KIND O
                 ELEMENT  O
              &END KIND
    """

    from collections.abc import Mapping, Sequence

    for key, val in sorted(params.items()):
        if key.upper() != key:  # keys are not case-insensitive, ensure that they follow the current scheme
            raise InputValidationError("keyword '%s' not upper case" % key)

        if key.startswith('@') or key.startswith('$'):
            raise InputValidationError("CP2K preprocessor directives not supported")

        ispace = ' ' * indent

        if isinstance(val, Mapping):
            section_param = val.pop('_', '')

            yield f"{ispace}&{key} {section_param}"
            yield from _render_cp2k_section(val, indent + indent_width)
            yield f"{ispace}&END {key}"

        elif isinstance(val, Sequence) and not isinstance(val, str):
            for listitem in val:
                yield from _render_cp2k_section({key: listitem}, indent)

        elif isinstance(val, bool):
            val_str = '.TRUE.' if val else '.FALSE.'
            yield f"{ispace}{key} {val_str}"

        else:
            yield f"{ispace}{key} {val}"
