# -*- coding: utf-8 -*-
###############################################################################
# Copyright (c), The AiiDA-CP2K authors.                                      #
# SPDX-License-Identifier: MIT                                                #
# AiiDA-CP2K is hosted on GitHub at https://github.com/aiidateam/aiida-cp2k   #
# For further information on the license, see the LICENSE.txt file.           #
###############################################################################
"""AiiDA-CP2K input plugin"""

from __future__ import absolute_import
from itertools import chain
from copy import deepcopy

import six

if six.PY2:
    from collections import Mapping, Sequence
else:
    from collections.abc import Mapping, Sequence


class Cp2kInput:
    """Transforms dictionary into CP2K input"""

    DISCLAIMER = "!!! Generated by AiiDA !!!"

    def __init__(self, params=None):
        if not params:
            self._params = {}
        else:
            # always make a full copy to avoid that add_keyword() changes the
            # passed-in dictionary
            self._params = deepcopy(params)

    def add_keyword(self, kwpath, value):
        """
        Add a value for the given keyword.

        Args:
            kwpath: Can be a single keyword, a path with `/` as divider for sections & key,
                    or a sequence with sections and key
            value: the value to set the given key to
        """

        if isinstance(kwpath, six.string_types):
            kwpath = kwpath.split("/")

        Cp2kInput._add_keyword(kwpath, value, self._params)

    def to_string(self):
        output = [self.DISCLAIMER]
        self._render_section(output, self._params)
        return "\n".join(
            chain([self.DISCLAIMER], Cp2kInput._render_section(self._params))
        )

    def to_file(self, fhandle):
        fhandle.write(u"{self.DISCLAIMER}".format(self=self))
        for line in Cp2kInput._render_section(self._params):
            fhandle.write(u"\n{line}".format(line=line))

    @staticmethod
    def _add_keyword(kwpath, value, params):
        """Add keyword in given nested dictionary"""

        if isinstance(params, Sequence):
            for seq in params:
                Cp2kInput._add_keyword(kwpath, value, seq)
            return

        if len(kwpath) == 1:  # key/value for the current level
            if kwpath[0] in params:
                if isinstance(params[kwpath[0]], Mapping) != isinstance(value, Mapping):
                    # only allow overwriting sections with other sections
                    raise ValueError(
                        "Overwriting a section with a bare key (resp. vice-versa) is not supported"
                    )
                if (
                    isinstance(params[kwpath[0]], Sequence)
                    and not isinstance(params[kwpath[0]], six.string_types)
                ) != (
                    isinstance(value, Sequence)
                    and not isinstance(value, six.string_types)
                ):
                    # only allow overwriting sequences (repeated sections) with other sequences,
                    # need to explicitly check for (seq,string), resp (string,seq) since strings are also sequences
                    raise ValueError(
                        "Overwriting repeated sections with a bare key (resp. vice-versa) is not supported"
                    )

            params[kwpath[0]] = value
            return

        if kwpath[0] not in params.keys():  # create an empty section if necessary
            params[kwpath[0]] = {}

        Cp2kInput._add_keyword(kwpath[1:], value, params[kwpath[0]])

    @staticmethod
    def _render_section(params, indent=0, indent_width=3):
        """
        It takes a dictionary and recurses through.

        For key-value pair it checks whether the value is a dictionary
        and prepends the key with & (CP2K section)
        It passes the valued to the same function, increasing the indentation
        If the value is a list, I assume that this is something the user
        wants to store repetitively
        eg:
            dict['KEY'] = ['val1', 'val2']
            ===>
            KEY val1
            KEY val2

            or

            dict['KIND'] = [{'_': 'Ba', 'ELEMENT':'Ba'},
                            {'_': 'Ti', 'ELEMENT':'Ti'},
                            {'_': 'O', 'ELEMENT':'O'}]
            ====>
                  &KIND Ba
                     ELEMENT  Ba
                  &END KIND
                  &KIND Ti
                     ELEMENT  Ti
                  &END KIND
                  &KIND O
                     ELEMENT  O
                  &END KIND
        """

        for key, val in sorted(params.items()):
            # the `_` is reserved for section params and evaluated in the prior call
            if key == "_":
                continue

            # keys are not case-insensitive, ensure that they follow the current scheme
            if key.upper() != key:
                raise ValueError("keyword '{key}' not upper case".format(key=key))

            if key.startswith(("@", "$")):
                raise ValueError("CP2K preprocessor directives not supported")

            ispace = " " * indent

            if isinstance(val, Mapping):
                line = "{ispace}&{key}".format(ispace=ispace, key=key)
                if "_" in val:  # if there is a section parameter, add it
                    line += " {}".format(val["_"])

                yield line
                # once we are on Python3-only, replace the following with a `yield from ...`
                for item in Cp2kInput._render_section(val, indent + indent_width):
                    yield item
                yield "{ispace}&END {key}".format(ispace=ispace, key=key)

            elif isinstance(val, Sequence) and not isinstance(val, six.string_types):
                for listitem in val:
                    # once we are on Python3-only, replace the following with a `yield from ...`
                    for line in Cp2kInput._render_section({key: listitem}, indent):
                        yield line

            elif isinstance(val, bool):
                val_str = ".TRUE." if val else ".FALSE."
                yield "{ispace}{key} {val_str}".format(
                    ispace=ispace, key=key, val_str=val_str
                )

            else:
                yield "{ispace}{key} {val}".format(ispace=ispace, key=key, val=val)
